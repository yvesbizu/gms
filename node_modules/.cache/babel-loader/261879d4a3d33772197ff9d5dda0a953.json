{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n$root.PBLink = function () {\n  /**\n   * Properties of a PBLink.\n   * @exports IPBLink\n   * @interface IPBLink\n   * @property {Uint8Array|null} [Hash] PBLink Hash\n   * @property {string|null} [Name] PBLink Name\n   * @property {number|null} [Tsize] PBLink Tsize\n   */\n\n  /**\n   * Constructs a new PBLink.\n   * @exports PBLink\n   * @classdesc Represents a PBLink.\n   * @implements IPBLink\n   * @constructor\n   * @param {IPBLink=} [p] Properties to set\n   */\n  function PBLink(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * PBLink Hash.\n   * @member {Uint8Array} Hash\n   * @memberof PBLink\n   * @instance\n   */\n  PBLink.prototype.Hash = $util.newBuffer([]);\n\n  /**\n   * PBLink Name.\n   * @member {string} Name\n   * @memberof PBLink\n   * @instance\n   */\n  PBLink.prototype.Name = \"\";\n\n  /**\n   * PBLink Tsize.\n   * @member {number} Tsize\n   * @memberof PBLink\n   * @instance\n   */\n  PBLink.prototype.Tsize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n\n  /**\n   * Encodes the specified PBLink message. Does not implicitly {@link PBLink.verify|verify} messages.\n   * @function encode\n   * @memberof PBLink\n   * @static\n   * @param {IPBLink} m PBLink message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PBLink.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.Hash != null && Object.hasOwnProperty.call(m, \"Hash\")) w.uint32(10).bytes(m.Hash);\n    if (m.Name != null && Object.hasOwnProperty.call(m, \"Name\")) w.uint32(18).string(m.Name);\n    if (m.Tsize != null && Object.hasOwnProperty.call(m, \"Tsize\")) w.uint32(24).uint64(m.Tsize);\n    return w;\n  };\n\n  /**\n   * Decodes a PBLink message from the specified reader or buffer.\n   * @function decode\n   * @memberof PBLink\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PBLink} PBLink\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PBLink.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.PBLink();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 1:\n          m.Hash = r.bytes();\n          break;\n        case 2:\n          m.Name = r.string();\n          break;\n        case 3:\n          m.Tsize = r.uint64();\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    return m;\n  };\n\n  /**\n   * Creates a PBLink message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PBLink\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PBLink} PBLink\n   */\n  PBLink.fromObject = function fromObject(d) {\n    if (d instanceof $root.PBLink) return d;\n    var m = new $root.PBLink();\n    if (d.Hash != null) {\n      if (typeof d.Hash === \"string\") $util.base64.decode(d.Hash, m.Hash = $util.newBuffer($util.base64.length(d.Hash)), 0);else if (d.Hash.length) m.Hash = d.Hash;\n    }\n    if (d.Name != null) {\n      m.Name = String(d.Name);\n    }\n    if (d.Tsize != null) {\n      if ($util.Long) (m.Tsize = $util.Long.fromValue(d.Tsize)).unsigned = true;else if (typeof d.Tsize === \"string\") m.Tsize = parseInt(d.Tsize, 10);else if (typeof d.Tsize === \"number\") m.Tsize = d.Tsize;else if (typeof d.Tsize === \"object\") m.Tsize = new $util.LongBits(d.Tsize.low >>> 0, d.Tsize.high >>> 0).toNumber(true);\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from a PBLink message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PBLink\n   * @static\n   * @param {PBLink} m PBLink\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PBLink.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.defaults) {\n      if (o.bytes === String) d.Hash = \"\";else {\n        d.Hash = [];\n        if (o.bytes !== Array) d.Hash = $util.newBuffer(d.Hash);\n      }\n      d.Name = \"\";\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.Tsize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.Tsize = o.longs === String ? \"0\" : 0;\n    }\n    if (m.Hash != null && m.hasOwnProperty(\"Hash\")) {\n      d.Hash = o.bytes === String ? $util.base64.encode(m.Hash, 0, m.Hash.length) : o.bytes === Array ? Array.prototype.slice.call(m.Hash) : m.Hash;\n    }\n    if (m.Name != null && m.hasOwnProperty(\"Name\")) {\n      d.Name = m.Name;\n    }\n    if (m.Tsize != null && m.hasOwnProperty(\"Tsize\")) {\n      if (typeof m.Tsize === \"number\") d.Tsize = o.longs === String ? String(m.Tsize) : m.Tsize;else d.Tsize = o.longs === String ? $util.Long.prototype.toString.call(m.Tsize) : o.longs === Number ? new $util.LongBits(m.Tsize.low >>> 0, m.Tsize.high >>> 0).toNumber(true) : m.Tsize;\n    }\n    return d;\n  };\n\n  /**\n   * Converts this PBLink to JSON.\n   * @function toJSON\n   * @memberof PBLink\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PBLink.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return PBLink;\n}();\n$root.PBNode = function () {\n  /**\n   * Properties of a PBNode.\n   * @exports IPBNode\n   * @interface IPBNode\n   * @property {Array.<IPBLink>|null} [Links] PBNode Links\n   * @property {Uint8Array|null} [Data] PBNode Data\n   */\n\n  /**\n   * Constructs a new PBNode.\n   * @exports PBNode\n   * @classdesc Represents a PBNode.\n   * @implements IPBNode\n   * @constructor\n   * @param {IPBNode=} [p] Properties to set\n   */\n  function PBNode(p) {\n    this.Links = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * PBNode Links.\n   * @member {Array.<IPBLink>} Links\n   * @memberof PBNode\n   * @instance\n   */\n  PBNode.prototype.Links = $util.emptyArray;\n\n  /**\n   * PBNode Data.\n   * @member {Uint8Array} Data\n   * @memberof PBNode\n   * @instance\n   */\n  PBNode.prototype.Data = $util.newBuffer([]);\n\n  /**\n   * Encodes the specified PBNode message. Does not implicitly {@link PBNode.verify|verify} messages.\n   * @function encode\n   * @memberof PBNode\n   * @static\n   * @param {IPBNode} m PBNode message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PBNode.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\")) w.uint32(10).bytes(m.Data);\n    if (m.Links != null && m.Links.length) {\n      for (var i = 0; i < m.Links.length; ++i) $root.PBLink.encode(m.Links[i], w.uint32(18).fork()).ldelim();\n    }\n    return w;\n  };\n\n  /**\n   * Decodes a PBNode message from the specified reader or buffer.\n   * @function decode\n   * @memberof PBNode\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PBNode} PBNode\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PBNode.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.PBNode();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 2:\n          if (!(m.Links && m.Links.length)) m.Links = [];\n          m.Links.push($root.PBLink.decode(r, r.uint32()));\n          break;\n        case 1:\n          m.Data = r.bytes();\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    return m;\n  };\n\n  /**\n   * Creates a PBNode message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PBNode\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PBNode} PBNode\n   */\n  PBNode.fromObject = function fromObject(d) {\n    if (d instanceof $root.PBNode) return d;\n    var m = new $root.PBNode();\n    if (d.Links) {\n      if (!Array.isArray(d.Links)) throw TypeError(\".PBNode.Links: array expected\");\n      m.Links = [];\n      for (var i = 0; i < d.Links.length; ++i) {\n        if (typeof d.Links[i] !== \"object\") throw TypeError(\".PBNode.Links: object expected\");\n        m.Links[i] = $root.PBLink.fromObject(d.Links[i]);\n      }\n    }\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from a PBNode message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PBNode\n   * @static\n   * @param {PBNode} m PBNode\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PBNode.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.arrays || o.defaults) {\n      d.Links = [];\n    }\n    if (o.defaults) {\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n    }\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n    if (m.Links && m.Links.length) {\n      d.Links = [];\n      for (var j = 0; j < m.Links.length; ++j) {\n        d.Links[j] = $root.PBLink.toObject(m.Links[j], o);\n      }\n    }\n    return d;\n  };\n\n  /**\n   * Converts this PBNode to JSON.\n   * @function toJSON\n   * @memberof PBNode\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PBNode.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return PBNode;\n}();\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}
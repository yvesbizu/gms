{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"ipfs-unixfs\"] || ($protobuf.roots[\"ipfs-unixfs\"] = {});\n$root.Data = function () {\n  /**\n   * Properties of a Data.\n   * @exports IData\n   * @interface IData\n   * @property {Data.DataType} Type Data Type\n   * @property {Uint8Array|null} [Data] Data Data\n   * @property {number|null} [filesize] Data filesize\n   * @property {Array.<number>|null} [blocksizes] Data blocksizes\n   * @property {number|null} [hashType] Data hashType\n   * @property {number|null} [fanout] Data fanout\n   * @property {number|null} [mode] Data mode\n   * @property {IUnixTime|null} [mtime] Data mtime\n   */\n\n  /**\n   * Constructs a new Data.\n   * @exports Data\n   * @classdesc Represents a Data.\n   * @implements IData\n   * @constructor\n   * @param {IData=} [p] Properties to set\n   */\n  function Data(p) {\n    this.blocksizes = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * Data Type.\n   * @member {Data.DataType} Type\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.Type = 0;\n\n  /**\n   * Data Data.\n   * @member {Uint8Array} Data\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.Data = $util.newBuffer([]);\n\n  /**\n   * Data filesize.\n   * @member {number} filesize\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n\n  /**\n   * Data blocksizes.\n   * @member {Array.<number>} blocksizes\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.blocksizes = $util.emptyArray;\n\n  /**\n   * Data hashType.\n   * @member {number} hashType\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n\n  /**\n   * Data fanout.\n   * @member {number} fanout\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n\n  /**\n   * Data mode.\n   * @member {number} mode\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.mode = 0;\n\n  /**\n   * Data mtime.\n   * @member {IUnixTime|null|undefined} mtime\n   * @memberof Data\n   * @instance\n   */\n  Data.prototype.mtime = null;\n\n  /**\n   * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n   * @function encode\n   * @memberof Data\n   * @static\n   * @param {IData} m Data message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Data.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\")) w.uint32(18).bytes(m.Data);\n    if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\")) w.uint32(24).uint64(m.filesize);\n    if (m.blocksizes != null && m.blocksizes.length) {\n      for (var i = 0; i < m.blocksizes.length; ++i) w.uint32(32).uint64(m.blocksizes[i]);\n    }\n    if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\")) w.uint32(40).uint64(m.hashType);\n    if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\")) w.uint32(48).uint64(m.fanout);\n    if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\")) w.uint32(56).uint32(m.mode);\n    if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\")) $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n    return w;\n  };\n\n  /**\n   * Decodes a Data message from the specified reader or buffer.\n   * @function decode\n   * @memberof Data\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Data} Data\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Data.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.Data();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 1:\n          m.Type = r.int32();\n          break;\n        case 2:\n          m.Data = r.bytes();\n          break;\n        case 3:\n          m.filesize = r.uint64();\n          break;\n        case 4:\n          if (!(m.blocksizes && m.blocksizes.length)) m.blocksizes = [];\n          if ((t & 7) === 2) {\n            var c2 = r.uint32() + r.pos;\n            while (r.pos < c2) m.blocksizes.push(r.uint64());\n          } else m.blocksizes.push(r.uint64());\n          break;\n        case 5:\n          m.hashType = r.uint64();\n          break;\n        case 6:\n          m.fanout = r.uint64();\n          break;\n        case 7:\n          m.mode = r.uint32();\n          break;\n        case 8:\n          m.mtime = $root.UnixTime.decode(r, r.uint32());\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    if (!m.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n      instance: m\n    });\n    return m;\n  };\n\n  /**\n   * Creates a Data message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Data\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Data} Data\n   */\n  Data.fromObject = function fromObject(d) {\n    if (d instanceof $root.Data) return d;\n    var m = new $root.Data();\n    switch (d.Type) {\n      case \"Raw\":\n      case 0:\n        m.Type = 0;\n        break;\n      case \"Directory\":\n      case 1:\n        m.Type = 1;\n        break;\n      case \"File\":\n      case 2:\n        m.Type = 2;\n        break;\n      case \"Metadata\":\n      case 3:\n        m.Type = 3;\n        break;\n      case \"Symlink\":\n      case 4:\n        m.Type = 4;\n        break;\n      case \"HAMTShard\":\n      case 5:\n        m.Type = 5;\n        break;\n    }\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n    if (d.filesize != null) {\n      if ($util.Long) (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;else if (typeof d.filesize === \"string\") m.filesize = parseInt(d.filesize, 10);else if (typeof d.filesize === \"number\") m.filesize = d.filesize;else if (typeof d.filesize === \"object\") m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n    }\n    if (d.blocksizes) {\n      if (!Array.isArray(d.blocksizes)) throw TypeError(\".Data.blocksizes: array expected\");\n      m.blocksizes = [];\n      for (var i = 0; i < d.blocksizes.length; ++i) {\n        if ($util.Long) (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;else if (typeof d.blocksizes[i] === \"string\") m.blocksizes[i] = parseInt(d.blocksizes[i], 10);else if (typeof d.blocksizes[i] === \"number\") m.blocksizes[i] = d.blocksizes[i];else if (typeof d.blocksizes[i] === \"object\") m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n      }\n    }\n    if (d.hashType != null) {\n      if ($util.Long) (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;else if (typeof d.hashType === \"string\") m.hashType = parseInt(d.hashType, 10);else if (typeof d.hashType === \"number\") m.hashType = d.hashType;else if (typeof d.hashType === \"object\") m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n    }\n    if (d.fanout != null) {\n      if ($util.Long) (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;else if (typeof d.fanout === \"string\") m.fanout = parseInt(d.fanout, 10);else if (typeof d.fanout === \"number\") m.fanout = d.fanout;else if (typeof d.fanout === \"object\") m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n    }\n    if (d.mode != null) {\n      m.mode = d.mode >>> 0;\n    }\n    if (d.mtime != null) {\n      if (typeof d.mtime !== \"object\") throw TypeError(\".Data.mtime: object expected\");\n      m.mtime = $root.UnixTime.fromObject(d.mtime);\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from a Data message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Data\n   * @static\n   * @param {Data} m Data\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Data.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.arrays || o.defaults) {\n      d.blocksizes = [];\n    }\n    if (o.defaults) {\n      d.Type = o.enums === String ? \"Raw\" : 0;\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.filesize = o.longs === String ? \"0\" : 0;\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.hashType = o.longs === String ? \"0\" : 0;\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.fanout = o.longs === String ? \"0\" : 0;\n      d.mode = 0;\n      d.mtime = null;\n    }\n    if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n    }\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n    if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n      if (typeof m.filesize === \"number\") d.filesize = o.longs === String ? String(m.filesize) : m.filesize;else d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n    }\n    if (m.blocksizes && m.blocksizes.length) {\n      d.blocksizes = [];\n      for (var j = 0; j < m.blocksizes.length; ++j) {\n        if (typeof m.blocksizes[j] === \"number\") d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];else d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n      }\n    }\n    if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n      if (typeof m.hashType === \"number\") d.hashType = o.longs === String ? String(m.hashType) : m.hashType;else d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n    }\n    if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n      if (typeof m.fanout === \"number\") d.fanout = o.longs === String ? String(m.fanout) : m.fanout;else d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n    }\n    if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n      d.mode = m.mode;\n    }\n    if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n      d.mtime = $root.UnixTime.toObject(m.mtime, o);\n    }\n    return d;\n  };\n\n  /**\n   * Converts this Data to JSON.\n   * @function toJSON\n   * @memberof Data\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Data.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  /**\n   * DataType enum.\n   * @name Data.DataType\n   * @enum {number}\n   * @property {number} Raw=0 Raw value\n   * @property {number} Directory=1 Directory value\n   * @property {number} File=2 File value\n   * @property {number} Metadata=3 Metadata value\n   * @property {number} Symlink=4 Symlink value\n   * @property {number} HAMTShard=5 HAMTShard value\n   */\n  Data.DataType = function () {\n    var valuesById = {},\n      values = Object.create(valuesById);\n    values[valuesById[0] = \"Raw\"] = 0;\n    values[valuesById[1] = \"Directory\"] = 1;\n    values[valuesById[2] = \"File\"] = 2;\n    values[valuesById[3] = \"Metadata\"] = 3;\n    values[valuesById[4] = \"Symlink\"] = 4;\n    values[valuesById[5] = \"HAMTShard\"] = 5;\n    return values;\n  }();\n  return Data;\n}();\n$root.UnixTime = function () {\n  /**\n   * Properties of an UnixTime.\n   * @exports IUnixTime\n   * @interface IUnixTime\n   * @property {number} Seconds UnixTime Seconds\n   * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n   */\n\n  /**\n   * Constructs a new UnixTime.\n   * @exports UnixTime\n   * @classdesc Represents an UnixTime.\n   * @implements IUnixTime\n   * @constructor\n   * @param {IUnixTime=} [p] Properties to set\n   */\n  function UnixTime(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * UnixTime Seconds.\n   * @member {number} Seconds\n   * @memberof UnixTime\n   * @instance\n   */\n  UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n  /**\n   * UnixTime FractionalNanoseconds.\n   * @member {number} FractionalNanoseconds\n   * @memberof UnixTime\n   * @instance\n   */\n  UnixTime.prototype.FractionalNanoseconds = 0;\n\n  /**\n   * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n   * @function encode\n   * @memberof UnixTime\n   * @static\n   * @param {IUnixTime} m UnixTime message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  UnixTime.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int64(m.Seconds);\n    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\")) w.uint32(21).fixed32(m.FractionalNanoseconds);\n    return w;\n  };\n\n  /**\n   * Decodes an UnixTime message from the specified reader or buffer.\n   * @function decode\n   * @memberof UnixTime\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {UnixTime} UnixTime\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  UnixTime.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.UnixTime();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 1:\n          m.Seconds = r.int64();\n          break;\n        case 2:\n          m.FractionalNanoseconds = r.fixed32();\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    if (!m.hasOwnProperty(\"Seconds\")) throw $util.ProtocolError(\"missing required 'Seconds'\", {\n      instance: m\n    });\n    return m;\n  };\n\n  /**\n   * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof UnixTime\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {UnixTime} UnixTime\n   */\n  UnixTime.fromObject = function fromObject(d) {\n    if (d instanceof $root.UnixTime) return d;\n    var m = new $root.UnixTime();\n    if (d.Seconds != null) {\n      if ($util.Long) (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;else if (typeof d.Seconds === \"string\") m.Seconds = parseInt(d.Seconds, 10);else if (typeof d.Seconds === \"number\") m.Seconds = d.Seconds;else if (typeof d.Seconds === \"object\") m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n    }\n    if (d.FractionalNanoseconds != null) {\n      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof UnixTime\n   * @static\n   * @param {UnixTime} m UnixTime\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  UnixTime.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.defaults) {\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, false);\n        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else d.Seconds = o.longs === String ? \"0\" : 0;\n      d.FractionalNanoseconds = 0;\n    }\n    if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n      if (typeof m.Seconds === \"number\") d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;else d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n    }\n    if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n      d.FractionalNanoseconds = m.FractionalNanoseconds;\n    }\n    return d;\n  };\n\n  /**\n   * Converts this UnixTime to JSON.\n   * @function toJSON\n   * @memberof UnixTime\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  UnixTime.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return UnixTime;\n}();\n$root.Metadata = function () {\n  /**\n   * Properties of a Metadata.\n   * @exports IMetadata\n   * @interface IMetadata\n   * @property {string|null} [MimeType] Metadata MimeType\n   */\n\n  /**\n   * Constructs a new Metadata.\n   * @exports Metadata\n   * @classdesc Represents a Metadata.\n   * @implements IMetadata\n   * @constructor\n   * @param {IMetadata=} [p] Properties to set\n   */\n  function Metadata(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * Metadata MimeType.\n   * @member {string} MimeType\n   * @memberof Metadata\n   * @instance\n   */\n  Metadata.prototype.MimeType = \"\";\n\n  /**\n   * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n   * @function encode\n   * @memberof Metadata\n   * @static\n   * @param {IMetadata} m Metadata message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metadata.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\")) w.uint32(10).string(m.MimeType);\n    return w;\n  };\n\n  /**\n   * Decodes a Metadata message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metadata\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Metadata} Metadata\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metadata.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.Metadata();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 1:\n          m.MimeType = r.string();\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    return m;\n  };\n\n  /**\n   * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metadata\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Metadata} Metadata\n   */\n  Metadata.fromObject = function fromObject(d) {\n    if (d instanceof $root.Metadata) return d;\n    var m = new $root.Metadata();\n    if (d.MimeType != null) {\n      m.MimeType = String(d.MimeType);\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metadata\n   * @static\n   * @param {Metadata} m Metadata\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metadata.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.defaults) {\n      d.MimeType = \"\";\n    }\n    if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n      d.MimeType = m.MimeType;\n    }\n    return d;\n  };\n\n  /**\n   * Converts this Metadata to JSON.\n   * @function toJSON\n   * @memberof Metadata\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metadata.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return Metadata;\n}();\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}
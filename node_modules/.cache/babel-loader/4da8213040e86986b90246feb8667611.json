{"ast":null,"code":"'use strict';\n\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar Bignumber = require('bignumber.js').BigNumber;\nvar constants = require('./constants');\nvar SHIFT32 = constants.SHIFT32;\nvar SHIFT16 = constants.SHIFT16;\nvar MAX_SAFE_HIGH = 0x1fffff;\nexports.parseHalf = function parseHalf(buf) {\n  var sign = buf[0] & 0x80 ? -1 : 1;\n  var exp = (buf[0] & 0x7C) >> 2;\n  var mant = (buf[0] & 0x03) << 8 | buf[1];\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308); // eslint-disable-line no-loss-of-precision\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant);\n  }\n};\nfunction toHex(n) {\n  if (n < 16) {\n    return '0' + n.toString(16);\n  }\n  return n.toString(16);\n}\nexports.arrayBufferToBignumber = function (buf) {\n  var len = buf.byteLength;\n  var res = '';\n  for (var i = 0; i < len; i++) {\n    res += toHex(buf[i]);\n  }\n  return new Bignumber(res, 16);\n};\n\n// convert an Object into a Map\nexports.buildMap = function (obj) {\n  var res = new Map();\n  var keys = Object.keys(obj);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]]);\n  }\n  return res;\n};\nexports.buildInt32 = function (f, g) {\n  return f * SHIFT16 + g;\n};\nexports.buildInt64 = function (f1, f2, g1, g2) {\n  var f = exports.buildInt32(f1, f2);\n  var g = exports.buildInt32(g1, g2);\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g);\n  } else {\n    return f * SHIFT32 + g;\n  }\n};\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  var u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  var u = u32.readUInt32BE(0);\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = u >> 16 & 0x8000; // top bit is sign\n  var exp = u >> 23 & 0xff; // then 5 bits of exponent\n  var mant = u & 0x7fffff;\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13);\n\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if (exp >= 103 && exp < 113) {\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n    s16 += mant + 0x800000 >> 126 - exp;\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n  } else {\n    return false;\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0);\n  return true;\n};\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength;\n  var lenB = b[0].byteLength;\n  if (lenA > lenB) {\n    return 1;\n  }\n  if (lenB > lenA) {\n    return -1;\n  }\n  return a[0].compare(b[0]);\n};\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = function (x) {\n  return x === 0 && 1 / x < 0;\n};\nexports.nextPowerOf2 = function (n) {\n  var count = 0;\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & n - 1)) {\n    return n;\n  }\n  while (n !== 0) {\n    n >>= 1;\n    count += 1;\n  }\n  return 1 << count;\n};","map":null,"metadata":{},"sourceType":"script"}
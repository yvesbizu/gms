{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yvesb\\\\OneDrive\\\\Desktop\\\\Hardhat\\\\front-end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\yvesb\\\\OneDrive\\\\Desktop\\\\Hardhat\\\\front-end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _require = require('./unixfs'),\n  PBData = _require.Data;\nvar errcode = require('err-code');\n\n/**\n * @typedef {import('./types').Mtime} Mtime\n * @typedef {import('./types').MtimeLike} MtimeLike\n */\n\nvar types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nvar dirTypes = ['directory', 'hamt-sharded-directory'];\nvar DEFAULT_FILE_MODE = parseInt('0644', 8);\nvar DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\n\n/**\n * @param {string | number | undefined} [mode]\n */\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n  if (typeof mode === 'number') {\n    return mode & 0xFFF;\n  }\n  mode = mode.toString();\n  if (mode.substring(0, 1) === '0') {\n    // octal string\n    return parseInt(mode, 8) & 0xFFF;\n  }\n\n  // decimal string\n  return parseInt(mode, 10) & 0xFFF;\n}\n\n/**\n * @param {any} input\n */\nfunction parseMtime(input) {\n  if (input == null) {\n    return undefined;\n  }\n\n  /** @type {Mtime | undefined} */\n  var mtime;\n\n  // { secs, nsecs }\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    };\n  }\n\n  // UnixFS TimeSpec\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    };\n  }\n\n  // process.hrtime()\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    };\n  }\n\n  // Javascript Date\n  if (input instanceof Date) {\n    var ms = input.getTime();\n    var secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n   // process.hrtime.bigint()\n  if (input instanceof BigInt) {\n    const secs = input / BigInt(1e9)\n    const nsecs = input - (secs * BigInt(1e9))\n     mtime = {\n      secs: parseInt(secs.toString()),\n      nsecs: parseInt(nsecs.toString())\n    }\n  }\n  */\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n  return mtime;\n}\nvar Data = /*#__PURE__*/function () {\n  _createClass(Data, null, [{\n    key: \"unmarshal\",\n    /**\n     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n     *\n     * @param {Uint8Array} marshaled\n     */\n    value: function unmarshal(marshaled) {\n      var message = PBData.decode(marshaled);\n      var decoded = PBData.toObject(message, {\n        defaults: false,\n        arrays: true,\n        longs: Number,\n        objects: false\n      });\n      var data = new Data({\n        type: types[decoded.Type],\n        data: decoded.Data,\n        blockSizes: decoded.blocksizes,\n        mode: decoded.mode,\n        mtime: decoded.mtime ? {\n          secs: decoded.mtime.Seconds,\n          nsecs: decoded.mtime.FractionalNanoseconds\n        } : undefined\n      });\n\n      // make sure we honour the original mode\n      data._originalMode = decoded.mode || 0;\n      return data;\n    }\n    /**\n     * @param {object} [options]\n     * @param {string} [options.type='file']\n     * @param {Uint8Array} [options.data]\n     * @param {number[]} [options.blockSizes]\n     * @param {number} [options.hashType]\n     * @param {number} [options.fanout]\n     * @param {MtimeLike | null} [options.mtime]\n     * @param {number | string} [options.mode]\n     */\n  }]);\n  function Data() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      type: 'file'\n    };\n    _classCallCheck(this, Data);\n    var type = options.type,\n      data = options.data,\n      blockSizes = options.blockSizes,\n      hashType = options.hashType,\n      fanout = options.fanout,\n      mtime = options.mtime,\n      mode = options.mode;\n    if (type && !types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    this.type = type || 'file';\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n\n    /** @type {number[]} */\n    this.blockSizes = blockSizes || [];\n    this._originalMode = 0;\n    this.mode = parseMode(mode);\n    if (mtime) {\n      this.mtime = parseMtime(mtime);\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0;\n      }\n    }\n  }\n\n  /**\n   * @param {number | undefined} mode\n   */\n  _createClass(Data, [{\n    key: \"isDirectory\",\n    value: function isDirectory() {\n      return Boolean(this.type && dirTypes.includes(this.type));\n    }\n    /**\n     * @param {number} size\n     */\n  }, {\n    key: \"addBlockSize\",\n    value: function addBlockSize(size) {\n      this.blockSizes.push(size);\n    }\n    /**\n     * @param {number} index\n     */\n  }, {\n    key: \"removeBlockSize\",\n    value: function removeBlockSize(index) {\n      this.blockSizes.splice(index, 1);\n    }\n    /**\n     * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else\n     */\n  }, {\n    key: \"fileSize\",\n    value: function fileSize() {\n      if (this.isDirectory()) {\n        // dirs don't have file size\n        return 0;\n      }\n      var sum = 0;\n      this.blockSizes.forEach(function (size) {\n        sum += size;\n      });\n      if (this.data) {\n        sum += this.data.length;\n      }\n      return sum;\n    }\n    /**\n     * encode to protobuf Uint8Array\n     */\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      var type;\n      switch (this.type) {\n        case 'raw':\n          type = PBData.DataType.Raw;\n          break;\n        case 'directory':\n          type = PBData.DataType.Directory;\n          break;\n        case 'file':\n          type = PBData.DataType.File;\n          break;\n        case 'metadata':\n          type = PBData.DataType.Metadata;\n          break;\n        case 'symlink':\n          type = PBData.DataType.Symlink;\n          break;\n        case 'hamt-sharded-directory':\n          type = PBData.DataType.HAMTShard;\n          break;\n        default:\n          throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n      }\n      var data = this.data;\n      if (!this.data || !this.data.length) {\n        data = undefined;\n      }\n      var mode;\n      if (this.mode != null) {\n        mode = this._originalMode & 0xFFFFF000 | (parseMode(this.mode) || 0);\n        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n          mode = undefined;\n        }\n        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n          mode = undefined;\n        }\n      }\n      var mtime;\n      if (this.mtime != null) {\n        var parsed = parseMtime(this.mtime);\n        if (parsed) {\n          mtime = {\n            Seconds: parsed.secs,\n            FractionalNanoseconds: parsed.nsecs\n          };\n          if (mtime.FractionalNanoseconds === 0) {\n            delete mtime.FractionalNanoseconds;\n          }\n        }\n      }\n      var pbData = {\n        Type: type,\n        Data: data,\n        filesize: this.isDirectory() ? undefined : this.fileSize(),\n        blocksizes: this.blockSizes,\n        hashType: this.hashType,\n        fanout: this.fanout,\n        mode: mode,\n        mtime: mtime\n      };\n      return PBData.encode(pbData).finish();\n    }\n  }, {\n    key: \"mode\",\n    set: function set(mode) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n      var parsedMode = parseMode(mode);\n      if (parsedMode !== undefined) {\n        this._mode = parsedMode;\n      }\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    ,\n    get: function get() {\n      return this._mode;\n    }\n  }]);\n  return Data;\n}();\nmodule.exports = {\n  UnixFS: Data,\n  parseMode: parseMode,\n  parseMtime: parseMtime\n};","map":null,"metadata":{},"sourceType":"script"}
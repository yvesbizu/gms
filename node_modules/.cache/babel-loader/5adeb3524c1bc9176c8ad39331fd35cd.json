{"ast":null,"code":"'use strict';\n\n/** @typedef {import('./types').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nvar _decode = function decode(string, alphabet, bitsPerChar) {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  var codes = {};\n  for (var i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  // Count the padding bytes:\n  var end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  // Allocate the output:\n  var out = new Uint8Array(end * bitsPerChar / 8 | 0);\n\n  // Parse the data:\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  var written = 0; // Next byte to write\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = codes[string[_i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    }\n\n    // Append the bits to the buffer:\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nvar _encode = function encode(data, alphabet, bitsPerChar) {\n  var pad = alphabet[alphabet.length - 1] === '=';\n  var mask = (1 << bitsPerChar) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\n\n/**\n * RFC4648 Factory\n *\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nvar rfc4648 = function rfc4648(bitsPerChar) {\n  return function (alphabet) {\n    return {\n      /**\n       * @param {Uint8Array} input\n       * @returns {string}\n       */\n      encode: function encode(input) {\n        return _encode(input, alphabet, bitsPerChar);\n      },\n      /**\n       * @param {string} input\n       * @returns {Uint8Array}\n       */\n      decode: function decode(input) {\n        return _decode(input, alphabet, bitsPerChar);\n      }\n    };\n  };\n};\nmodule.exports = {\n  rfc4648: rfc4648\n};","map":null,"metadata":{},"sourceType":"script"}